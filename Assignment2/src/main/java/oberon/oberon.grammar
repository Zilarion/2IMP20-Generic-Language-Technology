%package "oberon";
%class "OberonParser";

%terminals LETTER, DIGIT;
%terminals MULT, DIV, MOD, AND, PLUS, MIN, OR;
%terminals EQ, HASHTAG, LT, LEQ, GT, GEQ, DOT, COMMA, COLON, RPAREN, RBRACK;
%terminals OF, THEN, DO, LPAREN, LBRACK, COMP, ASSIGN, SEMICOLON;
%terminals END, ELSE, ELSIF, IF, WHILE;
%terminals ARRAY, RECORD, CONST, TYPE, VAR, PROCEDURE, BEGIN, MODULE;

%goal module;


ident
    = LETTER LETTER*
    | LETTER DIGIT*
    ;

integer = DIGIT+;

selector = selectorP*;

selectorP
    = DOT ident
    | LBRACK expression RBRACK
    ;

number = integer;

factor
    = ident selector
    | number
    | LPAREN expression RPAREN
    | COMP factor
    ;

term = factor termP*;

termP
    = MULT factor
    | DIV factor
    | MOD factor
    | AND factor
    ;

plusmin
    = +
    | -
    ;

simpleexp = plusmin? term simpleexpP*;

simpleexpP
    = PLUS term
    | MIN term
    | OR term
    ;

expression = simpleexp expressionP?;

expressionP
    = EQ simpleexp
    | HASHTAG simpleexp
    | LT simpleexp
    | LEQ simpleexp
    | GT simpleexp
    | GEQ simpleexp
    ;

assignment = ident selector ASSIGN expression;

actualpar = LPAREN actualparP? RPAREN;

actualparP = expression actualparPP*;

actualparPP = COMMA expression;

proccall = ident selector actualpar?;

ifstatement = IF expression THEN statementseq elsifstatement* elsestatement? END;

elsifstatement = ELSIF expression THEN statementseq;

elsestatement = ELSE statementseq;

whilestatement = WHILE expression DO statementseq END;

statement = statementP?;

statementP
    = assignment
    | proccall
    | ifstatement
    | whilestatement
    ;

statementseq = statement statementseqP*;

statementseqP = SEMICOLON statement;

identlist = ident identlistP*;

identlistP = COMMA ident;

arraytype = ARRAY expression OF type;

fieldlist = fieldlistP?;

fieldlistP = identlist COLON type;

recordtype = RECORD fieldlist recordtypeP* END;

recordtypeP = SEMICOLON fieldlist;

type
    = ident
    | arraytype
    | recordtype
    ;

fpsection = VAR? identlist COLON type;

formalpar = LPAREN formalparP? RPAREN;

formalparP = fpsection formalparPP*;

formalparPP = SEMICOLON fpsection;

prochead = PROCEDURE ident formalpar?;

procbody = declarations procbodyP? END ident;

procbodyP = BEGIN statementseq;

procdecl = prochead SEMICOLON procbody;

declarations =  declarationsM?
                declarationsT?
                declarationsV?
                declarationsP*;

declarationsM = CONST declarationsMP*;

declarationsMP = ident EQ expression SEMICOLON;

declarationsT = TYPE declarationsTP*;

declarationsTP = ident EQ TYPE SEMICOLON;

declarationsV = VAR declarationsVP*;

declarationsVP = identlist COLON TYPE SEMICOLON;

declarationsP = PROCDECL SEMICOLON;

module = MODULE ident SEMICOLON declarations moduleP? END ident DOT;

moduleP = BEGIN statementseq;