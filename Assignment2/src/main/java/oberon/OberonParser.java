package oberon;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "oberon.grammar".
 */
public class OberonParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short IDENT = 1;
		static public final short PLUS = 2;
		static public final short MIN = 3;
		static public final short SEMICOLON = 4;
		static public final short END = 5;
		static public final short RPAREN = 6;
		static public final short LPAREN = 7;
		static public final short INT = 8;
		static public final short COMP = 9;
		static public final short IF = 10;
		static public final short WHILE = 11;
		static public final short COLON = 12;
		static public final short ARRAY = 13;
		static public final short RECORD = 14;
		static public final short DOT = 15;
		static public final short COMMA = 16;
		static public final short EQ = 17;
		static public final short LBRACK = 18;
		static public final short VAR = 19;
		static public final short THEN = 20;
		static public final short PROC = 21;
		static public final short ELSIF = 22;
		static public final short MULT = 23;
		static public final short DIV = 24;
		static public final short MOD = 25;
		static public final short AND = 26;
		static public final short OR = 27;
		static public final short BEGIN = 28;
		static public final short CONST = 29;
		static public final short MODULE = 30;
		static public final short DO = 31;
		static public final short RBRACK = 32;
		static public final short ASSIGN = 33;
		static public final short OF = 34;
		static public final short HASHTAG = 35;
		static public final short LT = 36;
		static public final short LEQ = 37;
		static public final short GT = 38;
		static public final short GEQ = 39;
		static public final short ELSE = 40;
		static public final short TYPE = 41;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9orM6buLTKLNUVomc0Z2AWr5Yg5gY2GY8182HW84I828Wh8f0mMo40Oaq0O0XXc51GYyw0" +
		"8oYGoo4oGKLHcKK2fsgfjghRLrYeMkrtdlFrURkuNllxgkzywQ#zzzjdttZFTVHvWBk5wt8" +
		"Zgk0atuvUu1R41VKX0pmhe8mFws80#5zLAwRLG6pNH74yW4KqGXtjmBppSgjOQ#3s6eJEwe" +
		"2iUGtSao10qGW9wuN6qGakqrh8Xaf62Tb5EqFRDq5Cz4l4hb6FqSQoxMsllrxgmDf0rQrpq" +
		"lkXTAde2LYB4iWeg1#pXbeCmlbIauSgvU0idCLErXVIQmdUSXpryntorRi8AB4DvnD1QGJ9" +
		"n5dVYGMoXrtFiZKwOX5JCm7NOZLtOwNgZDdx3TjRh5yxw51wYxM7QVeSM#2tUbVEu7VLn5w" +
		"sFq5eRZxBCSrxTABr3xa7kXoTvXyM8a#NaOqYZjCJT8O8uLwx3QE8eZk0Zfx#AzTX0oqQyx" +
		"Z0VX$4YLc6pirlBFlKuxVXvIlMm7LlnQxoFIixZKjIt3WwuvxPeWlFql1UtHItrU5akGZhg" +
		"HgqM7T3HifoMKn6R777I10pWPQM9c2pFO1fcOIaovJc#vnHdNuFLM2s5ii1fI$0CTiZB7Ac" +
		"N9PtlEPJQQZmhct4E5UKr79GC76UPXggyRi0TQ81uDCO9D4KIxaCRjCK3Q8y#yfwSH7yCHW" +
		"uovB2yYH4OHJaRO$0UdiRRc8hfA421pCOSp9QvA4IXp9DdET8Bi0Wlo1mibqMo62$9VEp7M" +
		"hp6yWrimolalR89R#AGBAEy7wTmWTSPV03W8ZvqSxeHPtTZzc5Jzk3$Lw$AkLMVlT2GgweA" +
		"3DTHDOvjcwZrEixCEfo9jxElxcJzPCvEWmgSSHLGaJCWNDhL7yUL7c4JRJzQFH8vqstq59O" +
		"bqSDr4SrmvTde8zdN$kY6woF4SW3NTMbxf6NBGAG8FyHTeuFFwr6#OrVQgd7FYLXpEQR3wT" +
		"MCwpQ6#vF7lQKzlMeoVcjaSbvaSELsuVfhxteZtCvwrN3MPEv69RQUN5NbqOUxMc#rXiksK" +
		"QzyvIUuPWrdld5NAlT4mvRs3X4OBViJrRaJTdBwVMvtCDoBApiCvOmTpBqyRBUMY4UO9r2A" +
		"vseVnBqmY#zVuc6b5jnpx7DRLE4gYsVVZ8XQudbPpk5kqo9gjMYXUdbU4LkCAxjpNTtWf1x" +
		"i$n1NUnf79vkrXlrlxQre3KLRvl6x4c9jCuuo#9vrdLQ3NwjnR17BM37SRMrfMwLmJ9BuL8" +
		"aSATjVjTmpsgkykvBvHRhPZMGCzvuOocrfgSUMrUaVuhVg9ZUNObnfd5zDZaA8Ay4#aqKgO" +
		"VWyjLcsOtsiUuvOzhFHAzQL8NGISUs0o$bmlpf41Z6DM4li8dO2fe2eHKmWdgQj9Pa#PaQu" +
		"dPcfxGzRlXRuYoSwqB#PwdUKr9dcQkj8x5VvZFB3oidAxPJxAQ$qnObNdg#SHEHS#vbC6sA" +
		"knibI7gSyKNcwxnrcAS$tnNX0kODoH#NEobrBtvFx94oXrhr0T24M4e#ehRilzkF4R0hVaM" +
		"SHFOXbMhUSnVVa5KHlOYhrA#HLMZzFkH#nWCBLmBjF8XOHYrLVehnMUGCnW5X7B2Ks4eE8J" +
		"SJhn6PY2y4vPBPgcstAsvNN4vd43jzzxRpwWMpdrXvYDp6Ks4le69WCvOF4FgA2$zcrRXJn" +
		"4b59zID4Dd58zV7AnmFjYeXgAkSI1uWyrKy4V4y6z5FAfvMF4bmtvap0xwpoEULZH5tYlDz" +
		"FH4wKjE7k2wG6trFz8clXBetteEgcB7zVJDlsMrASwgTyTMkKhn856ZSoPwjgtNJLkoWFL7" +
		"k2xrsZyrNhcl#FPshlQvkcdAuS6VTCdyyjod6#69kLzoX7zWmTUnmBtBDoG5#WCNkhtjbNv" +
		"vw1$NOHuNtmEtzRsZzLlr6g5$kUTQ3MvMhTDwNlQoeHrrFegVgj$dfj#vDo7sK9#Z3k5P$$" +
		"EetbwxFmtXM8cnJGjsYxNEN6odEq$a8PCI9x$MVAOuaZllVBLtj16MsBbIDhObhGfopmDqp" +
		"zKtoshylmAr8$$txzOy3dClGdi#3x2VS4UKEsoNRP8KMoLVR9VjahUsItx9AVv5qfblVbOx" +
		"aiVw3q4Nq$bp$9P$85fJ$Aj$8F#KR#IVdlzFr1$YDNvR$KVfHYbbVaB$Ab$9LZzhtJ$qrmD" +
		"vU$4LyJNyc$M7vAV29$PlGFYKl4HU82yO6yBU#ubkUYJtk6zXDorbcBv9Yp7TAtA5O#84Vb" +
		"BVKuACTbfyoGQJ959ibauLTSXbwp7sRA11adusMYHikJV0H#mk#MFA$oKbabAsM5zQMsGTO" +
		"xviuiQsIzl2YloZfdUKNz#UsGZR95kBPaeHJ8L1aXmsIuZDJwB1abqoLNiYL7ngXjjDYPLi" +
		"Wit6RY7dDjk7ox3P58FT5bV1vXCyQmt8joBpA$ZOHnMLzI00reR#2oSUwjv3uE7dDXhb7Az" +
		"HchDVK8#jBUb$Q6b4TS0$Smg#AtYJ0yGvHZjcm8ZpapNDuyad8omUyoONYQAUVovFwqFKQR" +
		"pQQxaRkHcp3$RCjusQnhodok4UsDQ4yWxWvWW8F7amO8u$x1I26UecmpvHpQSrnsw34Vz9X" +
		"7XtW6065uFZ0y4PHZhcq8Znat2CDCEyGyqcFMRQ9enRfMUhAnupE6SXxR3YOFfkyGsePGpg" +
		"MSIgHHJwEUGV#nrDEffxkCEiRcaeHXvWt2CEy6ONXsiV1urW5Xc3U6U5emXCTJ0Tp9e2jbc" +
		"$rcKSwYpFbA6ERU7iyR8NvF3U7fyZVCn3rctY5czXvFJI3icR0YJqWUflmC3sP5P0==");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN7 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 7];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	static final Action RETURN8 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 8];
		}
	};

	private final Action[] actions;

	public OberonParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] lst$selectorP = selectorP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [1] lst$selectorP = lst$selectorP selectorP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [2] opt$lst$selectorP = 
			Action.RETURN,	// [3] opt$lst$selectorP = lst$selectorP
			Action.RETURN,	// [4] selector = opt$lst$selectorP
			RETURN2,	// [5] selectorP = DOT IDENT; returns 'IDENT' although none is marked
			RETURN3,	// [6] selectorP = LBRACK expression RBRACK; returns 'RBRACK' although none is marked
			RETURN2,	// [7] factor = IDENT selector; returns 'selector' although none is marked
			Action.RETURN,	// [8] factor = INT
			RETURN3,	// [9] factor = LPAREN expression RPAREN; returns 'RPAREN' although none is marked
			RETURN2,	// [10] factor = COMP factor; returns 'factor' although none is marked
			new Action() {	// [11] lst$termP = termP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [12] lst$termP = lst$termP termP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [13] opt$lst$termP = 
			Action.RETURN,	// [14] opt$lst$termP = lst$termP
			RETURN2,	// [15] term = factor opt$lst$termP; returns 'opt$lst$termP' although none is marked
			RETURN2,	// [16] termP = MULT factor; returns 'factor' although none is marked
			RETURN2,	// [17] termP = DIV factor; returns 'factor' although none is marked
			RETURN2,	// [18] termP = MOD factor; returns 'factor' although none is marked
			RETURN2,	// [19] termP = AND factor; returns 'factor' although none is marked
			Action.RETURN,	// [20] plusmin = PLUS
			Action.RETURN,	// [21] plusmin = MIN
			Action.NONE,  	// [22] opt$plusmin = 
			Action.RETURN,	// [23] opt$plusmin = plusmin
			new Action() {	// [24] lst$simpleexpP = simpleexpP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [25] lst$simpleexpP = lst$simpleexpP simpleexpP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [26] opt$lst$simpleexpP = 
			Action.RETURN,	// [27] opt$lst$simpleexpP = lst$simpleexpP
			RETURN3,	// [28] simpleexp = opt$plusmin term opt$lst$simpleexpP; returns 'opt$lst$simpleexpP' although none is marked
			RETURN2,	// [29] simpleexpP = PLUS term; returns 'term' although none is marked
			RETURN2,	// [30] simpleexpP = MIN term; returns 'term' although none is marked
			RETURN2,	// [31] simpleexpP = OR term; returns 'term' although none is marked
			Action.NONE,  	// [32] opt$expressionP = 
			Action.RETURN,	// [33] opt$expressionP = expressionP
			RETURN2,	// [34] expression = simpleexp opt$expressionP; returns 'opt$expressionP' although none is marked
			RETURN2,	// [35] expressionP = EQ simpleexp; returns 'simpleexp' although none is marked
			RETURN2,	// [36] expressionP = HASHTAG simpleexp; returns 'simpleexp' although none is marked
			RETURN2,	// [37] expressionP = LT simpleexp; returns 'simpleexp' although none is marked
			RETURN2,	// [38] expressionP = LEQ simpleexp; returns 'simpleexp' although none is marked
			RETURN2,	// [39] expressionP = GT simpleexp; returns 'simpleexp' although none is marked
			RETURN2,	// [40] expressionP = GEQ simpleexp; returns 'simpleexp' although none is marked
			RETURN4,	// [41] assignment = IDENT selector ASSIGN expression; returns 'expression' although none is marked
			Action.NONE,  	// [42] opt$actualparP = 
			Action.RETURN,	// [43] opt$actualparP = actualparP
			RETURN3,	// [44] actualpar = LPAREN opt$actualparP RPAREN; returns 'RPAREN' although none is marked
			new Action() {	// [45] lst$actualparPP = actualparPP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [46] lst$actualparPP = lst$actualparPP actualparPP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [47] opt$lst$actualparPP = 
			Action.RETURN,	// [48] opt$lst$actualparPP = lst$actualparPP
			RETURN2,	// [49] actualparP = expression opt$lst$actualparPP; returns 'opt$lst$actualparPP' although none is marked
			RETURN2,	// [50] actualparPP = COMMA expression; returns 'expression' although none is marked
			Action.NONE,  	// [51] opt$actualpar = 
			Action.RETURN,	// [52] opt$actualpar = actualpar
			RETURN3,	// [53] proccall = IDENT selector opt$actualpar; returns 'opt$actualpar' although none is marked
			new Action() {	// [54] lst$elsifstatement = elsifstatement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [55] lst$elsifstatement = lst$elsifstatement elsifstatement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [56] opt$lst$elsifstatement = 
			Action.RETURN,	// [57] opt$lst$elsifstatement = lst$elsifstatement
			Action.NONE,  	// [58] opt$elsestatement = 
			Action.RETURN,	// [59] opt$elsestatement = elsestatement
			RETURN7,	// [60] ifstatement = IF expression THEN statementseq opt$lst$elsifstatement opt$elsestatement END; returns 'END' although none is marked
			RETURN4,	// [61] elsifstatement = ELSIF expression THEN statementseq; returns 'statementseq' although none is marked
			RETURN2,	// [62] elsestatement = ELSE statementseq; returns 'statementseq' although none is marked
			RETURN5,	// [63] whilestatement = WHILE expression DO statementseq END; returns 'END' although none is marked
			Action.NONE,  	// [64] opt$statementP = 
			Action.RETURN,	// [65] opt$statementP = statementP
			Action.RETURN,	// [66] statement = opt$statementP
			Action.RETURN,	// [67] statementP = assignment
			Action.RETURN,	// [68] statementP = proccall
			Action.RETURN,	// [69] statementP = ifstatement
			Action.RETURN,	// [70] statementP = whilestatement
			new Action() {	// [71] lst$statementseqP = statementseqP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [72] lst$statementseqP = lst$statementseqP statementseqP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [73] opt$lst$statementseqP = 
			Action.RETURN,	// [74] opt$lst$statementseqP = lst$statementseqP
			RETURN2,	// [75] statementseq = statement opt$lst$statementseqP; returns 'opt$lst$statementseqP' although none is marked
			RETURN2,	// [76] statementseqP = SEMICOLON statement; returns 'statement' although none is marked
			new Action() {	// [77] lst$IDENTlistP = IDENTlistP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [78] lst$IDENTlistP = lst$IDENTlistP IDENTlistP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [79] opt$lst$IDENTlistP = 
			Action.RETURN,	// [80] opt$lst$IDENTlistP = lst$IDENTlistP
			RETURN2,	// [81] IDENTlist = IDENT opt$lst$IDENTlistP; returns 'opt$lst$IDENTlistP' although none is marked
			RETURN2,	// [82] IDENTlistP = COMMA IDENT; returns 'IDENT' although none is marked
			RETURN4,	// [83] arraytype = ARRAY expression OF type; returns 'type' although none is marked
			Action.NONE,  	// [84] opt$fieldlistP = 
			Action.RETURN,	// [85] opt$fieldlistP = fieldlistP
			Action.RETURN,	// [86] fieldlist = opt$fieldlistP
			RETURN3,	// [87] fieldlistP = IDENTlist COLON type; returns 'type' although none is marked
			new Action() {	// [88] lst$recordtypeP = recordtypeP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [89] lst$recordtypeP = lst$recordtypeP recordtypeP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [90] opt$lst$recordtypeP = 
			Action.RETURN,	// [91] opt$lst$recordtypeP = lst$recordtypeP
			RETURN4,	// [92] recordtype = RECORD fieldlist opt$lst$recordtypeP END; returns 'END' although none is marked
			RETURN2,	// [93] recordtypeP = SEMICOLON fieldlist; returns 'fieldlist' although none is marked
			Action.RETURN,	// [94] type = IDENT
			Action.RETURN,	// [95] type = arraytype
			Action.RETURN,	// [96] type = recordtype
			Action.NONE,  	// [97] opt$VAR = 
			Action.RETURN,	// [98] opt$VAR = VAR
			RETURN4,	// [99] fpsection = opt$VAR IDENTlist COLON type; returns 'type' although none is marked
			Action.NONE,  	// [100] opt$formalparP = 
			Action.RETURN,	// [101] opt$formalparP = formalparP
			RETURN3,	// [102] formalpar = LPAREN opt$formalparP RPAREN; returns 'RPAREN' although none is marked
			new Action() {	// [103] lst$formalparPP = formalparPP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [104] lst$formalparPP = lst$formalparPP formalparPP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [105] opt$lst$formalparPP = 
			Action.RETURN,	// [106] opt$lst$formalparPP = lst$formalparPP
			RETURN2,	// [107] formalparP = fpsection opt$lst$formalparPP; returns 'opt$lst$formalparPP' although none is marked
			RETURN2,	// [108] formalparPP = SEMICOLON fpsection; returns 'fpsection' although none is marked
			Action.NONE,  	// [109] opt$procbodyP = 
			Action.RETURN,	// [110] opt$procbodyP = procbodyP
			RETURN4,	// [111] procbody = declarations opt$procbodyP END IDENT; returns 'IDENT' although none is marked
			RETURN2,	// [112] procbodyP = BEGIN statementseq; returns 'statementseq' although none is marked
			Action.NONE,  	// [113] opt$formalpar = 
			Action.RETURN,	// [114] opt$formalpar = formalpar
			RETURN5,	// [115] procdecl = PROC IDENT opt$formalpar SEMICOLON procbody; returns 'procbody' although none is marked
			Action.NONE,  	// [116] opt$declarationsM = 
			Action.RETURN,	// [117] opt$declarationsM = declarationsM
			Action.NONE,  	// [118] opt$declarationsT = 
			Action.RETURN,	// [119] opt$declarationsT = declarationsT
			Action.NONE,  	// [120] opt$declarationsV = 
			Action.RETURN,	// [121] opt$declarationsV = declarationsV
			new Action() {	// [122] lst$declarationsP = declarationsP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [123] lst$declarationsP = lst$declarationsP declarationsP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [124] opt$lst$declarationsP = 
			Action.RETURN,	// [125] opt$lst$declarationsP = lst$declarationsP
			RETURN4,	// [126] declarations = opt$declarationsM opt$declarationsT opt$declarationsV opt$lst$declarationsP; returns 'opt$lst$declarationsP' although none is marked
			new Action() {	// [127] lst$declarationsMP = declarationsMP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [128] lst$declarationsMP = lst$declarationsMP declarationsMP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [129] opt$lst$declarationsMP = 
			Action.RETURN,	// [130] opt$lst$declarationsMP = lst$declarationsMP
			RETURN2,	// [131] declarationsM = CONST opt$lst$declarationsMP; returns 'opt$lst$declarationsMP' although none is marked
			RETURN4,	// [132] declarationsMP = IDENT EQ expression SEMICOLON; returns 'SEMICOLON' although none is marked
			new Action() {	// [133] lst$declarationsTP = declarationsTP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [134] lst$declarationsTP = lst$declarationsTP declarationsTP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [135] opt$lst$declarationsTP = 
			Action.RETURN,	// [136] opt$lst$declarationsTP = lst$declarationsTP
			RETURN2,	// [137] declarationsT = TYPE opt$lst$declarationsTP; returns 'opt$lst$declarationsTP' although none is marked
			RETURN4,	// [138] declarationsTP = IDENT EQ type SEMICOLON; returns 'SEMICOLON' although none is marked
			new Action() {	// [139] lst$declarationsVP = declarationsVP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [140] lst$declarationsVP = lst$declarationsVP declarationsVP
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [141] opt$lst$declarationsVP = 
			Action.RETURN,	// [142] opt$lst$declarationsVP = lst$declarationsVP
			RETURN2,	// [143] declarationsV = VAR opt$lst$declarationsVP; returns 'opt$lst$declarationsVP' although none is marked
			RETURN4,	// [144] declarationsVP = IDENTlist COLON type SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN2,	// [145] declarationsP = procdecl SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.NONE,  	// [146] opt$moduleP = 
			Action.RETURN,	// [147] opt$moduleP = moduleP
			RETURN8,	// [148] module = MODULE IDENT SEMICOLON declarations opt$moduleP END IDENT DOT; returns 'DOT' although none is marked
			RETURN2	// [149] moduleP = BEGIN statementseq; returns 'statementseq' although none is marked
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
